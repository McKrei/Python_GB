'''
Создайте собственный класс-исключение, который должен проверять содержимое списка на
наличие только чисел. Проверить работу исключения на реальном примере. Запрашивать у
пользователя данные и заполнять список необходимо только числами. Класс-исключение
должен контролировать типы данных элементов списка.
Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока
пользователь сам не остановит работу скрипта, введя, например, команду «stop». При этом
скрипт завершается, сформированный список с числами выводится на экран.
Подсказка: для этого задания примем, что пользователь может вводить только числа и строки.
Во время ввода пользователем очередного элемента необходимо реализовать проверку типа
элемента. Вносить его в список, только если введено число. Класс-исключение должен не
позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение.
При этом работа скрипта не должна завершаться.
'''



class NotPrimeError(Exception):
	def __init__(self, txt):
		self.txt = txt

	@staticmethod
	def isPrime(n): # Хоть куда то засунуть сие творение! 
		if n == 2 or n == 3: True
		elif n%2 == 0: return False
		for j in range(3, int(n**0.5)+1):
			if (not (n%j)):
				return False
		return True


class LineError(Exception):
	def __init__(self, txt):
		self.txt = txt

result = []
print('Давай посмотрим сколько простых чисел ты знаешь! Надоест, жми "stop"')

while True:	
	number = input('Введите прстое число: ')
	if number == 'stop':
		print(f'Ваш список чисел {sorted(set(result))}')
		break
	try:
		if number.isalpha():
			raise LineError('Введина строка!')

		elif float(number) %1 != 0:
			print('Только натуральные число.')
			continue

		elif NotPrimeError.isPrime(int(number)) == False:
			raise NotPrimeError('Совсем не простое число.')

		result.append(int(number))

	except LineError as err:
			print(err)
			continue

	except NotPrimeError as err:
			print(err)
			continue

	else: 
		print(f'Число {number} принято')







