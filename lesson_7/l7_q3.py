'''
Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо
создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий
количеству ячеек клетки (целое число). В классе должны быть реализованы методы
перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),
умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только
к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением
до целого) деление клеток, соответственно.
'''

class Cell:

	def __init__(self, summ):
		self.summ = summ

	def __str__(self):
		return f'Клетка, имеет {self.summ} ячеек'

	@property
	def summ(self):
		return self.__summ

	@summ.setter # Так и не понял как работает .setter в методичке дали пример, я скопировал. 
	def summ(self, summ):
		try:
			if summ < 1: self.__summ = 1
			else: self.__summ = int(summ)
		except Exception: # Не получилос добавить ValueError and TypeError, через запятую. 
			self.__summ = 6

# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
# сумме ячеек исходных двух клеток.

	def __add__(self, other):
		return Cell(self.summ + other.summ)

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.

	def __sub__(self, other):
		if self.summ - other.summ <= 0: return print('Разность меньше 1')
		return Cell(self.summ - other.summ)

# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# произведение количества ячеек этих двух клеток.

	def __mul__(self, other):
		return Cell(self.summ * other.summ)

# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток.

	def __truediv__(self, other):
		return Cell(self.summ / other.summ) # Могу себе позволить оставить обычное деление 

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний
# ряд записываются все оставшиеся.

	def make_order(self, row): # Чет я не прочитав задание до конца начал выполнять и 2-ды переделал :-) 
		s = ''                 # 3-й раз с перегрузкой не стал! 
		for i in range(self.summ // row):
			s += '*'*row + '\n'
		s += '*'*row
		x = self.summ % row
		if x != 0:
			s += '\n' + '*'*x
		return s

cell_1 = Cell(44.478)
cell_2 = Cell('Много')
cell_3 = cell_1 / cell_2
print(cell_3)
print(cell_1.make_order(6))
